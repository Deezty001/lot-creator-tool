<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Connector Lot Creator</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        #map {
            height: 100vh;
            width: 100%;
            z-index: 0;
            cursor: grab;
        }
        .sidebar {
            z-index: 1000;
        }
        /* Pulse animation for the active selection dots */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(255, 82, 82, 0); }
            100% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(255, 82, 82, 0); }
        }
        .active-dot-icon {
            background-color: #ef4444;
            border-radius: 50%;
            border: 2px solid white;
            animation: pulse-ring 2s infinite;
        }
        /* Type Selector Styles */
        .type-btn.active {
            border-color: #2563eb;
            background-color: #eff6ff;
            color: #1d4ed8;
            font-weight: bold;
        }
        .trace-mode-active {
            background-color: #fef3c7 !important; /* Amber-100 */
            border-color: #f59e0b !important; /* Amber-500 */
            color: #b45309 !important;
            font-weight: bold;
        }
        /* Toast notification */
        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 8px;
            padding: 16px;
            position: fixed;
            z-index: 2000;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
        }
        #toast.show {
            visibility: visible;
            opacity: 1;
            bottom: 50px;
        }
    </style>
</head>
<body class="bg-gray-100 overflow-hidden">

    <!-- Sidebar -->
    <div class="sidebar absolute top-4 left-4 w-80 bg-white rounded-xl shadow-2xl flex flex-col max-h-[90vh]" id="sidebar">
        
        <!-- Header -->
        <div class="p-4 border-b border-gray-200 bg-slate-900 text-white rounded-t-xl">
            <h1 class="font-bold text-lg"><i class="fa-solid fa-circle-nodes mr-2"></i>Connect-the-Dots</h1>
            <p class="text-xs text-slate-400">Click corners to build lots</p>
        </div>

        <!-- Content -->
        <div class="p-4 overflow-y-auto flex-1 space-y-5">
            
            <!-- 1. Upload -->
            <div class="space-y-2">
                <label class="block text-xs font-bold uppercase text-gray-500 tracking-wide">1. Load Points</label>
                <label for="file-upload" class="flex flex-col items-center justify-center w-full h-16 border-2 border-slate-300 border-dashed rounded-lg cursor-pointer bg-slate-50 hover:bg-slate-100 transition-colors">
                    <div class="flex items-center justify-center">
                        <i class="fa-solid fa-cloud-arrow-up text-slate-400 mr-2"></i>
                        <span class="text-xs text-slate-500 font-medium">Upload .geojson</span>
                    </div>
                    <input id="file-upload" type="file" class="hidden" accept=".geojson,.json" />
                </label>
                <div id="point-count" class="hidden text-xs text-blue-600 font-bold text-center">
                    0 points loaded
                </div>
            </div>

            <!-- 2. Active Selection -->
            <div class="space-y-2 border-t border-gray-100 pt-4">
                <div class="flex justify-between items-center">
                    <label class="block text-xs font-bold uppercase text-gray-500 tracking-wide">2. Build Shape</label>
                    <button id="trace-toggle" class="text-[10px] border border-gray-300 px-2 py-1 rounded bg-white hover:bg-gray-50 transition-colors shadow-sm" title="Disables map panning to let you paint over dots">
                        <i class="fa-solid fa-paintbrush mr-1"></i> Trace Mode
                    </button>
                </div>
                <p class="text-[10px] text-gray-400 mb-2">Toggle Trace Mode. <span class="text-orange-600 font-bold">Drag back to start to finish.</span></p>
                
                <div class="bg-slate-50 p-3 rounded border border-slate-200">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs font-bold text-slate-700">Selected Points:</span>
                        <span id="selection-count" class="bg-slate-200 text-slate-700 text-xs px-2 py-0.5 rounded-full">0</span>
                    </div>
                    
                    <!-- Controls -->
                    <div class="flex gap-2">
                        <button id="undo-btn" class="flex-1 bg-white border border-gray-300 text-gray-600 text-xs py-2 rounded hover:bg-gray-50" title="Ctrl+Z">
                            <i class="fa-solid fa-rotate-left"></i> Undo
                        </button>
                        <button id="clear-btn" class="flex-1 bg-white border border-red-200 text-red-600 text-xs py-2 rounded hover:bg-red-50">
                            <i class="fa-solid fa-trash"></i> Clear
                        </button>
                    </div>
                </div>
            </div>

            <!-- 3. Type & Create -->
            <div class="space-y-3 border-t border-gray-100 pt-4">
                <label class="block text-xs font-bold uppercase text-gray-500 tracking-wide">3. Finalize</label>
                
                <!-- Type Selector -->
                <div class="grid grid-cols-2 gap-2">
                    <button class="type-btn active border border-gray-200 rounded py-2 text-xs font-medium text-gray-600 hover:bg-gray-50 transition-all flex items-center justify-center" data-type="lot">
                        <i class="fa-solid fa-house-chimney text-gray-300 mr-2"></i> Lot
                    </button>
                    <button class="type-btn border border-gray-200 rounded py-2 text-xs font-medium text-gray-600 hover:bg-gray-50 transition-all flex items-center justify-center" data-type="road">
                        <i class="fa-solid fa-road text-slate-800 mr-2"></i> Road
                    </button>
                    <button class="type-btn border border-gray-200 rounded py-2 text-xs font-medium text-gray-600 hover:bg-gray-50 transition-all flex items-center justify-center" data-type="park">
                        <i class="fa-solid fa-tree text-green-500 mr-2"></i> Park
                    </button>
                    <button class="type-btn border border-gray-200 rounded py-2 text-xs font-medium text-gray-600 hover:bg-gray-50 transition-all flex items-center justify-center" data-type="footpath">
                        <i class="fa-solid fa-person-walking text-gray-500 mr-2"></i> Path
                    </button>
                </div>

                <button id="create-btn" class="w-full text-white bg-blue-600 hover:bg-blue-700 font-bold rounded-lg text-sm px-5 py-3 shadow-md transition-all flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                    <i class="fa-solid fa-check mr-2"></i> Create Shape
                </button>

                <!-- Smoother Tool -->
                <div class="bg-gray-50 p-3 rounded-lg border border-gray-200 space-y-2 mt-2">
                    <h3 class="text-xs font-bold text-gray-700 uppercase"><i class="fa-solid fa-bezier-curve mr-1"></i> Smooth Helper</h3>
                    <button id="smooth-btn" class="w-full bg-white border border-gray-300 hover:bg-gray-100 text-gray-700 text-xs font-bold py-2 px-2 rounded shadow-sm transition-colors">
                        Smooth Corners
                    </button>
                    <div class="flex items-center gap-2 mt-1">
                        <span class="text-[10px] text-gray-500">Curviness:</span>
                        <input id="tension-slider" type="range" min="0.1" max="0.95" step="0.05" value="0.75" class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
            </div>

            <!-- 4. Export -->
            <div class="border-t border-gray-100 pt-4">
                 <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-gray-500 uppercase">Total Shapes:</span>
                    <span id="total-lots" class="text-sm font-bold text-green-700">0</span>
                </div>
                <button id="download-btn" class="w-full text-blue-600 bg-white border border-blue-600 hover:bg-blue-50 font-medium rounded-lg text-xs px-4 py-2 transition-all">
                    Download GeoJSON
                </button>
            </div>

        </div>
    </div>

    <!-- Map -->
    <div id="map"></div>
    
    <!-- Toast -->
    <div id="toast">Shape Created!</div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <script>
        let map;
        let pointsLayer = null;    
        let linesLayer = null;     
        let previewLine = null;    
        let finishedLots = null;   
        
        let selectedPoints = [];   
        let currentType = 'lot';
        let traceMode = false;
        let isMouseDown = false;
        
        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            setupEventListeners();
        });

        function initMap() {
            map = L.map('map', { preferCanvas: true }).setView([-34.82, 150.58], 17);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 21,
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            finishedLots = new L.FeatureGroup().addTo(map);
            
            // Preview line setup
            previewLine = L.polyline([], {
                color: 'red',
                weight: 3,
                dashArray: '5, 5',
                opacity: 0.8
            }).addTo(map);

            // Global Mouse listeners for Trace Mode
            map.on('mousedown', () => { isMouseDown = true; });
            map.on('mouseup', () => { isMouseDown = false; });
            document.addEventListener('mouseup', () => { isMouseDown = false; }); // Catch outside map
        }

        function setupEventListeners() {
            document.getElementById('file-upload').addEventListener('change', handleFileUpload);
            document.getElementById('create-btn').addEventListener('click', createShape);
            document.getElementById('undo-btn').addEventListener('click', undoSelection);
            document.getElementById('clear-btn').addEventListener('click', clearSelection);
            document.getElementById('download-btn').addEventListener('click', downloadData);
            document.getElementById('smooth-btn').addEventListener('click', smoothLots);
            
            // Global Undo Listener (Ctrl+Z)
            document.addEventListener('keydown', (e) => {
                // Check for Ctrl+Z or Cmd+Z
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault(); // Prevent browser undo
                    
                    // Logic: If user is selecting points, undo point.
                    // If user is idle, undo the last created finished lot.
                    if (selectedPoints.length > 0) {
                        undoSelection();
                    } else {
                        undoLastShape();
                    }
                }
            });
            
            // Trace Mode Toggle Logic
            const traceBtn = document.getElementById('trace-toggle');
            traceBtn.addEventListener('click', () => {
                traceMode = !traceMode;
                
                // --- NEW: Toggle interactivity of existing lots ---
                finishedLots.eachLayer(l => {
                    // Setting interactive to false makes events pass through the polygon
                    if (l.setStyle) {
                        l.setStyle({ interactive: !traceMode });
                    }
                });

                if(traceMode) {
                    traceBtn.classList.add('trace-mode-active');
                    traceBtn.innerHTML = '<i class="fa-solid fa-paintbrush mr-1"></i> Trace ON (Lots Locked)';
                    // Lock Map dragging so we can draw
                    map.dragging.disable();
                    map.getContainer().style.cursor = 'crosshair';
                } else {
                    traceBtn.classList.remove('trace-mode-active');
                    traceBtn.innerHTML = '<i class="fa-solid fa-paintbrush mr-1"></i> Trace Mode';
                    // Unlock Map dragging
                    map.dragging.enable();
                    map.getContainer().style.cursor = 'grab';
                }
            });

            // Type Selector Logic
            const typeBtns = document.querySelectorAll('.type-btn');
            typeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active from all
                    typeBtns.forEach(b => b.classList.remove('active'));
                    // Add active to clicked
                    btn.classList.add('active');
                    // Set State
                    currentType = btn.getAttribute('data-type');
                });
            });
        }

        // --- File Processing ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    processGeoJSON(json);
                } catch (err) {
                    alert("Error: " + err.message);
                }
            };
            reader.readAsText(file);
        }

        function processGeoJSON(data) {
            if(pointsLayer) map.removeLayer(pointsLayer);
            if(linesLayer) map.removeLayer(linesLayer);
            selectedPoints = [];
            updateUI();

            linesLayer = L.geoJSON(data, {
                style: { color: '#94a3b8', weight: 1, opacity: 0.5 },
                interactive: false
            }).addTo(map);
            
            map.fitBounds(linesLayer.getBounds());

            const exploded = turf.explode(data);
            
            pointsLayer = L.geoJSON(exploded, {
                pointToLayer: function (feature, latlng) {
                    // Use bigger interaction area for easier tracing
                    return L.circleMarker(latlng, {
                        radius: 5, // Visual radius
                        fillColor: "#3b82f6", 
                        color: "#fff",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                        className: 'hover:cursor-pointer'
                    });
                },
                onEachFeature: (feature, layer) => {
                    // Click to Select (Normal Mode)
                    layer.on('click', () => {
                        if(!traceMode) handleDotSelect(layer);
                    });

                    // Trace Mode Logic (Hover while mouse down)
                    layer.on('mouseover', () => {
                        if (traceMode && isMouseDown) {
                            handleDotSelect(layer);
                        } else {
                            // Visual hover only if not already selected
                            if(!isLayerSelected(layer)) {
                                layer.setStyle({ radius: 8, fillColor: '#2563eb' });
                            }
                        }
                    });

                    layer.on('mouseout', () => {
                        if(!isLayerSelected(layer)) {
                            layer.setStyle({ radius: 5, fillColor: '#3b82f6' });
                        }
                    });
                    
                    // Mouse Down on a dot starts tracing instantly in Trace Mode
                    layer.on('mousedown', () => {
                        if(traceMode) handleDotSelect(layer);
                    });
                }
            }).addTo(map);

            const count = exploded.features.length;
            document.getElementById('point-count').innerText = `${count} points active`;
            document.getElementById('point-count').classList.remove('hidden');
        }

        // --- Interaction Logic ---
        function handleDotSelect(layer) {
            const latlng = layer.getLatLng();
            const coord = [latlng.lng, latlng.lat]; 

            // --- AUTO-CLOSE (Universal) ---
            // If we have started drawing (>= 3 points) and we click/drag back to the start point
            if (selectedPoints.length >= 3) {
                const start = selectedPoints[0];
                if (start[0] === coord[0] && start[1] === coord[1]) {
                    createShape(); // Auto-finish
                    showToast("Loop closed! Shape created.");
                    return;
                }
            }

            // Prevent duplicates if hovering same dot twice (general case)
            if(isLayerSelected(layer)) return;

            // Visual Feedback
            layer.setStyle({ fillColor: '#ef4444', radius: 7, color: 'white', weight: 2 });
            
            selectedPoints.push(coord);
            updatePreviewLine();
            updateUI();
        }
        
        function isLayerSelected(layer) {
             const ll = layer.getLatLng();
             return selectedPoints.some(p => p[0] === ll.lng && p[1] === ll.lat);
        }

        function updatePreviewLine() {
            const latlngs = selectedPoints.map(p => [p[1], p[0]]);
            previewLine.setLatLngs(latlngs);
        }

        function undoSelection() {
            if (selectedPoints.length === 0) return;
            selectedPoints.pop();
            resetPointStyles();
            updatePreviewLine();
            updateUI();
        }

        function undoLastShape() {
            const layers = finishedLots.getLayers();
            if (layers.length > 0) {
                const lastLayer = layers[layers.length - 1];
                finishedLots.removeLayer(lastLayer);
                updateTotalCount();
                showToast("Undo: Last shape removed");
            }
        }

        function clearSelection() {
            selectedPoints = [];
            resetPointStyles();
            updatePreviewLine();
            updateUI();
        }
        
        function resetPointStyles() {
            if(!pointsLayer) return;
            
            // Reset all first
            pointsLayer.eachLayer(layer => {
                layer.setStyle({ radius: 5, fillColor: '#3b82f6', color: '#fff', weight: 1 });
            });
            
            // Re-highlight selected
            pointsLayer.eachLayer(layer => {
                const ll = layer.getLatLng();
                const isSel = selectedPoints.some(p => p[0] === ll.lng && p[1] === ll.lat);
                if(isSel) {
                    layer.setStyle({ fillColor: '#ef4444', radius: 7, color: 'white', weight: 2 });
                }
            });
        }

        function updateUI() {
            document.getElementById('selection-count').innerText = selectedPoints.length;
            const btn = document.getElementById('create-btn');
            
            if(selectedPoints.length >= 3) {
                btn.disabled = false;
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // --- Creation Logic ---
        function createShape() {
            // Min points check
            if (selectedPoints.length < 3) return;

            try {
                // All modes behave as polygons (Point-to-Point perimeter)
                const ring = [...selectedPoints];
                // Ensure closed
                if(ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1]) {
                    ring.push(ring[0]); 
                }
                let poly = turf.polygon([ring]);

                // Apply Styles
                let style = { weight: 2, fillOpacity: 0.6 };
                let popupTitle = "Unknown";
                
                if (currentType === 'lot') {
                    // Lightest (White/Light Grey)
                    style.color = "#cbd5e1"; // Slate-300 border
                    style.weight = 2; // Keep border
                    style.fillColor = "#f8fafc"; // Slate-50 fill
                    popupTitle = "Lot (For Sale)";
                    poly.properties = { type: 'lot', status: 'for_sale', price: 0 };
                } else if (currentType === 'road') {
                    // Darkest (Dark Grey/Black) NO BORDER
                    style.stroke = false; 
                    style.fillColor = "#334155"; // Slate-700 fill
                    style.fillOpacity = 0.8;
                    popupTitle = "Road";
                    poly.properties = { type: 'road' };
                } else if (currentType === 'park') {
                    // Green
                    style.color = "#15803d"; 
                    style.weight = 2; // Keep border
                    style.fillColor = "#4ade80"; 
                    popupTitle = "Park";
                    poly.properties = { type: 'park' };
                } else if (currentType === 'footpath') {
                    // Middle (Medium Grey) NO BORDER
                    style.stroke = false;
                    style.fillColor = "#9ca3af"; // Gray-400 fill
                    style.fillOpacity = 0.8;
                    popupTitle = "Footpath";
                    poly.properties = { type: 'footpath' };
                }

                // Add Area & ID
                const area = turf.area(poly);
                poly.properties.area_sqm = area;
                poly.properties.id = Date.now();

                // Add to Map
                L.geoJSON(poly, {
                    style: style,
                    interactive: !traceMode, // Set initial interactivity based on mode
                    onEachFeature: (f, l) => {
                        const txt = f.properties.area_sqm.toFixed(1) + " mÂ²";
                        l.bindPopup(`<strong>${popupTitle}</strong><br>Area: ${txt}`);
                        l.on('contextmenu', (e) => {
                            if(confirm("Delete this shape?")) {
                                finishedLots.removeLayer(l);
                                updateTotalCount();
                            }
                        });
                    }
                }).addTo(finishedLots);

                clearSelection();
                updateTotalCount();
                showToast("Shape created!");

            } catch (err) {
                console.error(err);
                alert("Failed to create shape. " + err.message);
            }
        }

        function smoothLots() {
            const tension = parseFloat(document.getElementById('tension-slider').value) || 0.75;
            let count = 0;

            finishedLots.eachLayer(layer => {
                const geo = layer.toGeoJSON();
                try {
                    let line = turf.polygonToLine(geo);
                    if(line.type === 'FeatureCollection') line = line.features[0];
                    
                    const smoothed = turf.bezierSpline(line, {
                        resolution: 10000, 
                        sharpness: tension 
                    });
                    
                    const coords = smoothed.geometry.coordinates;
                    coords.push(coords[0]); 
                    const poly = turf.polygon([coords]);
                    poly.properties = geo.properties; 

                    const newLatLngs = L.geoJSON(poly).getLayers()[0].getLatLngs();
                    layer.setLatLngs(newLatLngs);
                    count++;
                } catch (e) { console.log(e); }
            });

            if(count > 0) {
                const btn = document.getElementById('smooth-btn');
                const originalText = btn.innerText;
                btn.innerText = "Smoothed!";
                setTimeout(() => { btn.innerText = originalText; }, 1500);
            }
        }

        function updateTotalCount() {
            document.getElementById('total-lots').innerText = finishedLots.getLayers().length;
        }

        function downloadData() {
            const layers = finishedLots.getLayers();
            if (layers.length === 0) {
                alert("No lots created yet.");
                return;
            }
            const features = layers.map(l => {
                if(l.feature) return l.toGeoJSON();
                if(l.getLayers) return l.getLayers()[0].toGeoJSON();
                return null;
            }).filter(f => f);

            const collection = turf.featureCollection(features);
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(collection));
            const node = document.createElement('a');
            node.setAttribute("href", dataStr);
            node.setAttribute("download", "master_plan.geojson");
            document.body.appendChild(node);
            node.click();
            node.remove();
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.innerText = msg;
            toast.className = "show";
            setTimeout(function(){ toast.className = toast.className.replace("show", ""); }, 3000);
        }
    </script>
</body>
</html>
